

# State update equations (AKA YDOT if you calculate them all)
PaDot = LDot * bPa1 + LambdaDot * bPa2 + HDot * bPa3 + math.cos(t) * bPa4 - math.sin(t) * bPa5
TaDot = LDot * bTa1 + LambdaDot * bTa2 + HDot * bTa3 + math.cos(t) * bTa4 - math.sin(t) * bTa5
VwnDot = LDot * bVwn1 + LambdaDot * bVwn2 + HDot * bVwn3 + math.cos(t) * bVwn4 - math.sin(t) * bVwn5
VweDot = LDot * bVwe1 + LambdaDot * bVwe2 + HDot * bVwe3 + math.cos(t) * bVwe4 - math.sin(t) * bVwe5
VwdDot = 0
DPpDot = 0
alphaState = 0
betaState = 0

# Q = TRANSPOSE(YDOT)*YDOT + some noise for Vwd and DPp

# Measurement equations

PaAtmoModel = L * bPa1 + Lambda * bPa2 + H * bPa3 + math.sin(Omega * t) * bPa4 + math.cos(Omega * t) * bPa5
TaAtmoModel = L * bTa1 + Lambda * bTa2 + H * bTa3 + math.sin(Omega * t) * bTa4 + math.cos(Omega * t) * bTa5
alphaEstimate = theta + math.asin(VgDMeasured * (VgDMeasured ** 2 + VgEMeasured ** 2 + VgNMeasured ** 2) ** (-0.1e1 / 0.2e1))
betaEstimate = math.acos(VgNMeasured * (VgEMeasured ** 2 + VgNMeasured ** 2) ** (-0.1e1 / 0.2e1)) - psi

VgNMeasured = math.cos(theta) * math.cos(psi) * math.cos(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + (-math.cos(phi) * math.sin(psi) + math.sin(phi) * math.sin(theta) * math.cos(psi)) * math.sin(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + (math.sin(phi) * math.sin(psi) + math.cos(phi) * math.sin(theta) * math.cos(psi)) * math.sin(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + VwnState
VgEMeasured = math.cos(theta) * math.sin(psi) * math.cos(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + (math.cos(phi) * math.cos(psi) + math.sin(phi) * math.sin(theta) * math.sin(psi)) * math.sin(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + (-math.sin(phi) * math.cos(psi) + math.cos(phi) * math.sin(theta) * math.sin(psi)) * math.sin(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + VweState
VgDMeasured = -math.sin(theta) * math.cos(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + math.sin(phi) * math.cos(theta) * math.sin(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + math.cos(phi) * math.cos(theta) * math.sin(alpha) * math.cos(beta) * TAS(DPpState, TaState, PsMeasured, PtMeasured) + VwdState
PsMeasured = PaState + DPpState
PaAtmoModel = PaState
TaAtmoModel = TaState
alphaEstimate = alphaState
betaEstimate = betaState
alphaMeasured = alphaState
betaMeasured = betaState


# R is block diagonal
# for VgNED - maybe cov(diff(VgN VgE VgD))? no real basis for this
# for Ps, variance(diff(PsMeasured))
# for PaAtmoModel, TaAtmoModel, cov from AtmoModel
# for alphaEstimate and betaEstimate, cov(diff( trick ?
# for alphaMeasured and betaMeasured, cov(diff( trick ?

# need to define the function "Mach(DPp,Ps,Pt)"
H = numpy.mat([[0,math.cos(thetaMeasured) * math.cos(psiMeasured) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + (-math.cos(phiMeasured) * math.sin(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + (math.sin(phiMeasured) * math.sin(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2,1,0,0,math.cos(thetaMeasured) * math.cos(psiMeasured) * math.cos(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + (-math.cos(phiMeasured) * math.sin(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.sin(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + (math.sin(phiMeasured) * math.sin(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.sin(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2,-math.cos(thetaMeasured) * math.cos(psiMeasured) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + (math.sin(phiMeasured) * math.sin(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL),-math.cos(thetaMeasured) * math.cos(psiMeasured) * math.cos(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + (-math.cos(phiMeasured) * math.sin(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) - (math.sin(phiMeasured) * math.sin(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.cos(psiMeasured)) * math.sin(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL)],[0,math.cos(thetaMeasured) * math.sin(psiMeasured) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + (math.cos(phiMeasured) * math.cos(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + (-math.sin(phiMeasured) * math.cos(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2,0,1,0,math.cos(thetaMeasured) * math.sin(psiMeasured) * math.cos(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + (math.cos(phiMeasured) * math.cos(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.sin(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + (-math.sin(phiMeasured) * math.cos(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.sin(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2,-math.cos(thetaMeasured) * math.sin(psiMeasured) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + (-math.sin(phiMeasured) * math.cos(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL),-math.cos(thetaMeasured) * math.sin(psiMeasured) * math.cos(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + (math.cos(phiMeasured) * math.cos(psiMeasured) + math.sin(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) - (-math.sin(phiMeasured) * math.cos(psiMeasured) + math.cos(phiMeasured) * math.sin(thetaMeasured) * math.sin(psiMeasured)) * math.sin(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL)],[0,-math.sin(thetaMeasured) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + math.sin(phiMeasured) * math.cos(thetaMeasured) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2 + math.cos(phiMeasured) * math.cos(thetaMeasured) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * (TaState / TSL) ** (-0.1e1 / 0.2e1) / TSL / 2,0,0,1,-math.sin(thetaMeasured) * math.cos(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + math.sin(phiMeasured) * math.cos(thetaMeasured) * math.sin(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2 + math.cos(phiMeasured) * math.cos(thetaMeasured) * math.sin(alphaState) * math.cos(betaState) * (Mach(DPpState + DPpIncr, PsMeasured, PtMeasured) - Mach(DPpState - DPpIncr, PsMeasured, PtMeasured)) / DPpIncr * aSL * math.sqrt(TaState / TSL) / 2,math.sin(thetaMeasured) * math.sin(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + math.cos(phiMeasured) * math.cos(thetaMeasured) * math.cos(alphaState) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL),math.sin(thetaMeasured) * math.cos(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) + math.sin(phiMeasured) * math.cos(thetaMeasured) * math.cos(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL) - math.cos(phiMeasured) * math.cos(thetaMeasured) * math.sin(alphaState) * math.sin(betaState) * Mach(DPpState, PsMeasured, PtMeasured) * aSL * math.sqrt(TaState / TSL)],[1,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1]])
